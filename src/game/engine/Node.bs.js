// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var CarLike$Netgame = require("../skills/CarLike.bs.js");
var Movable$Netgame = require("../skills/Movable.bs.js");

function childrenReduce(_children, _action) {
  while(true) {
    var action = _action;
    var children = _children;
    switch (action.TAG | 0) {
      case /* Add */0 :
          return Belt_Array.concat(children, [action._0]);
      case /* Remove */1 :
          var child = action._0;
          return Belt_Array.keep(children, (function(child){
                    return function (c) {
                      return Caml_obj.caml_notequal(c, child);
                    }
                    }(child)));
      case /* Update */2 :
          var child$1 = action._0;
          _action = {
            TAG: /* Add */0,
            _0: Curry._1(action._1, child$1)
          };
          _children = childrenReduce(children, {
                TAG: /* Remove */1,
                _0: child$1
              });
          continue ;
      
    }
  };
}

function reduce(t, action) {
  switch (action.TAG | 0) {
    case /* ZOrder */0 :
        return {
                skills: t.skills,
                zOrder: Curry._1(action._0, t.zOrder),
                children: t.children
              };
    case /* Children */1 :
        return {
                skills: t.skills,
                zOrder: t.zOrder,
                children: childrenReduce(t.children, action._0)
              };
    case /* Skills */2 :
        return {
                skills: Curry._1(action._0, t.skills),
                zOrder: t.zOrder,
                children: t.children
              };
    
  }
}

function skillsStep(skills, input, dt) {
  var carLike = skills.carLike;
  var skills$1;
  if (carLike !== undefined) {
    var movable = Belt_Option.getExn(skills.movable);
    var transform = Belt_Option.getExn(skills.transform);
    var match = CarLike$Netgame.step([
          carLike,
          movable,
          transform
        ], input, dt);
    skills$1 = {
      sprite: skills.sprite,
      transform: match[2],
      movable: match[1],
      carLike: match[0]
    };
  } else {
    skills$1 = skills;
  }
  var movable$1 = skills$1.movable;
  if (movable$1 === undefined) {
    return skills$1;
  }
  var transform$1 = Belt_Option.getExn(skills$1.transform);
  var match$1 = Movable$Netgame.step([
        movable$1,
        transform$1
      ], dt);
  return {
          sprite: skills$1.sprite,
          transform: match$1[1],
          movable: match$1[0],
          carLike: skills$1.carLike
        };
}

function step(t, input, dt) {
  return {
          skills: skillsStep(t.skills, input, dt),
          zOrder: t.zOrder,
          children: Belt_Array.map(t.children, (function (__x) {
                  return step(__x, input, dt);
                }))
        };
}

var childStep = step;

exports.childrenReduce = childrenReduce;
exports.reduce = reduce;
exports.skillsStep = skillsStep;
exports.childStep = childStep;
exports.step = step;
/* No side effect */
