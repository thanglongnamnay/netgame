// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { Pos, PosT } from './pos';
import { Touch } from './touch';


export class Payload {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
__init(i:number, bb:flatbuffers.ByteBuffer):Payload {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

touch():Touch {
  return this.bb!.readInt8(this.bb_pos);
}

pos(obj?:Pos):Pos|null {
  return (obj || new Pos()).__init(this.bb_pos + 2, this.bb!);
}

static sizeOf():number {
  return 6;
}

static createPayload(builder:flatbuffers.Builder, touch: Touch, pos_x: number, pos_y: number):flatbuffers.Offset {
  builder.prep(2, 6);
  builder.prep(2, 4);
  builder.writeInt16(pos_y);
  builder.writeInt16(pos_x);
  builder.pad(1);
  builder.writeInt8(touch);
  return builder.offset();
}


unpack(): PayloadT {
  return new PayloadT(
    this.touch(),
    (this.pos() !== null ? this.pos()!.unpack() : null)
  );
}


unpackTo(_o: PayloadT): void {
  _o.touch = this.touch();
  _o.pos = (this.pos() !== null ? this.pos()!.unpack() : null);
}
}

export class PayloadT {
constructor(
  public touch: Touch = Touch.Up,
  public pos: PosT|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return Payload.createPayload(builder,
    this.touch,
    (this.pos === null ? 0 : this.pos.x!),
    (this.pos === null ? 0 : this.pos.y!)
  );
}
}
