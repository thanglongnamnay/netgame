// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");

function deserialize(schema, deserializer) {
  switch (schema.TAG | 0) {
    case /* Bool */0 :
        if (deserializer === 0) {
          return schema._0;
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case /* Byte */1 :
        if (deserializer === 1) {
          return schema._0;
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case /* Short */2 :
        if (deserializer === 2) {
          return schema._0;
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case /* Int */3 :
        if (deserializer === 3) {
          return schema._0;
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case /* Float */4 :
        if (typeof deserializer === "number") {
          if (deserializer >= 4) {
            return schema._0;
          }
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case /* Array */5 :
        var v = schema._0;
        if (typeof deserializer === "number") {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        if (deserializer.TAG !== /* Array */0) {
          return Belt_Array.map(v, deserializer._0);
        }
        var deserializer$1 = deserializer._0;
        return Belt_Array.map(v, (function (schema) {
                      return deserialize(schema, deserializer$1);
                    }));
    case /* Schema */6 :
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    
  }
}

var toList = Belt_Array.map;

function toArray(t) {
  return t;
}

function size(data) {
  switch (data.TAG | 0) {
    case /* Bool */0 :
    case /* Byte */1 :
        return 1;
    case /* Short */2 :
        return 2;
    case /* Int */3 :
    case /* Float */4 :
        return 4;
    case /* Array */5 :
        return Belt_Array.reduce(data._0, 0, (function (a, v) {
                      return a + size(v) | 0;
                    })) + 4 | 0;
    case /* Schema */6 :
        return Belt_Array.reduce(data._0, 0, (function (a, v) {
                      return a + size(v) | 0;
                    }));
    
  }
}

function packData(buffer, _offsetOpt, _data) {
  while(true) {
    var offsetOpt = _offsetOpt;
    var data = _data;
    var offset = offsetOpt !== undefined ? offsetOpt : 0;
    switch (data.TAG | 0) {
      case /* Bool */0 :
          return buffer.writeInt8(data._0 ? 1 : 0, offset);
      case /* Byte */1 :
          return buffer.writeInt8(data._0, offset);
      case /* Short */2 :
          return buffer.writeInt16LE(data._0, offset);
      case /* Int */3 :
          return buffer.writeInt32LE(data._0, offset);
      case /* Float */4 :
          return buffer.writeFloatLE(data._0, offset);
      case /* Array */5 :
          var t = data._0;
          var offset$1 = buffer.writeInt32LE(t.length, offset);
          _data = {
            TAG: /* Schema */6,
            _0: t
          };
          _offsetOpt = offset$1;
          continue ;
      case /* Schema */6 :
          return Belt_Array.reduce(data._0, offset, (function (a, v) {
                        return packData(buffer, a, v);
                      }));
      
    }
  };
}

function pack(t) {
  var buffer = Buffer.alloc(size(t));
  packData(buffer, 0, t);
  return buffer;
}

function fromSendSchema(sendSchema) {
  switch (sendSchema.TAG | 0) {
    case /* Bool */0 :
        return /* Bool */0;
    case /* Byte */1 :
        return /* Byte */1;
    case /* Short */2 :
        return /* Short */2;
    case /* Int */3 :
        return /* Int */3;
    case /* Float */4 :
        return /* Float */4;
    case /* Array */5 :
        return {
                TAG: /* Array */0,
                _0: fromSendSchema(Belt_Array.getExn(sendSchema._0, 0))
              };
    case /* Schema */6 :
        return {
                TAG: /* Schema */1,
                _0: Belt_Array.map(sendSchema._0, fromSendSchema)
              };
    
  }
}

function readData(buffer, offsetOpt, schema) {
  var offset = offsetOpt !== undefined ? offsetOpt : 0;
  if (typeof schema === "number") {
    switch (schema) {
      case /* Bool */0 :
          return {
                  data: {
                    TAG: /* Bool */0,
                    _0: buffer.readInt8(offset) > 0
                  },
                  offset: offset + 1 | 0
                };
      case /* Byte */1 :
          return {
                  data: {
                    TAG: /* Byte */1,
                    _0: buffer.readInt8(offset)
                  },
                  offset: offset + 1 | 0
                };
      case /* Short */2 :
          return {
                  data: {
                    TAG: /* Short */2,
                    _0: buffer.readInt16LE(offset)
                  },
                  offset: offset + 2 | 0
                };
      case /* Int */3 :
          return {
                  data: {
                    TAG: /* Int */3,
                    _0: buffer.readInt32LE(offset)
                  },
                  offset: offset + 4 | 0
                };
      case /* Float */4 :
          return {
                  data: {
                    TAG: /* Float */4,
                    _0: buffer.readFloatLE(offset)
                  },
                  offset: offset + 4 | 0
                };
      
    }
  } else {
    if (schema.TAG === /* Array */0) {
      var match = readData(buffer, offset, /* Int */3);
      var length = match.data;
      if (length.TAG === /* Int */3) {
        var match$1 = Belt_Array.reduce(Belt_Array.make(length._0, schema._0), [
              [],
              match.offset
            ], (function (a, v) {
                var dataRead = readData(buffer, a[1], v);
                return [
                        Belt_Array.concat(a[0], [dataRead.data]),
                        dataRead.offset
                      ];
              }));
        return {
                data: {
                  TAG: /* Array */5,
                  _0: match$1[0]
                },
                offset: match$1[1]
              };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    var match$2 = Belt_Array.reduce(schema._0, [
          [],
          offset
        ], (function (a, v) {
            var dataRead = readData(buffer, a[1], v);
            return [
                    Belt_Array.concat(a[0], [dataRead.data]),
                    dataRead.offset
                  ];
          }));
    return {
            data: {
              TAG: /* Schema */6,
              _0: match$2[0]
            },
            offset: match$2[1]
          };
  }
}

function read(buffer, schema) {
  return readData(buffer, 0, fromSendSchema(schema)).data;
}

var Deserializer = {};

exports.Deserializer = Deserializer;
exports.deserialize = deserialize;
exports.toList = toList;
exports.toArray = toArray;
exports.pack = pack;
exports.read = read;
/* No side effect */
